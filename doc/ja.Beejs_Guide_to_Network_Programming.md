# Beej's Guide to Network Programming
Using Internet Sockets

Brian “Beej Jorgensen” Hall

v3.1.5, Copyright © November 20, 2020

## 2 ソケットとは
ソケットという言葉をよく耳にしますが、そもそも"ソケット"とは何なのでしょうか？それは、標準的なUnixのファイルディスクリプタを使って他のプログラムと会話するための方法です。

何と？

Unixのハッカーが、"なんてこった、Unixのすべてはファイルだ！"と言ったのを聞いたことがあるかもしれません。その人が言っているのは、Unixのプログラムが何らかのI/Oを行うとき、ファイル記述子に対して読み書きを行うという事実のことでしょう。ファイルディスクリプタは、単純に、開いているファイルに関連する整数です。しかし、このファイルは、ネットワーク接続、FIFO、パイプ、ターミナル、ディスク上のファイルなど、あらゆるものになり得ます（ここが重要）。Unix ではすべてがファイルなのです! だから、インターネット上で他のプログラムと通信したいときは、ファイル記述子を介して行うことになる。

"ネットワーク通信のためのファイルディスクリプタはどこで手に入るのでしょうか、お利口さんですね "というのが、今あなたが考えている最後の質問でしょうが、とにかくそれに答えてあげましょう。システムルーチンのsocket()を呼び出すのです。socket()システムルーチンを呼び出すと、ソケットディスクリプタが返され、それを使って特殊な send() と recv() (man send, man recv) ソケットコールを使って通信を行います。

"でもね！"あなたは今まさにそう叫んでいるかもしれません。"ファイルディスクリプタなら、なぜネプチューンの名において、通常の read() や write() 呼び出しでソケットを通して通信できないんだ？" と。短い答えは、"できる！"です。もっと長い答えは、"できるけど、send() や recv() の方がデータ転送をより細かく制御できる "です。

次は何？どうでしょう、ソケットにはいろいろな種類がありますね。DARPA インターネットアドレス (インターネットソケット)、ローカルノード上のパス名 (Unix ソケット)、CCITT X.25 アドレス (X.25 ソケット、無視しても大丈夫)、そしておそらくあなたが実行する Unix のフレーバーに応じて他の多くの種類があります。この文書では、最初のインターネットソケットのみを扱います。

### 2.1 2種類のインターネットソケット
これは何？インターネットソケットには2種類ある？そうです。まあ、違うけど。嘘です。もっとあるんだけど、怖がらせたくなかったんだ。ここでは2種類しか話しません。ただし、この文章では、"Raw Sockets"も非常に強力なので、ぜひ調べてみてください、と書いています。

わかったよ、もう。この2つのタイプは何ですか？一つは"ストリームソケット"、もう一つは"データグラムソケット"で、以下それぞれ"SOCK_STREAM" "SOCK_DGRAM"と表記することがあります。データグラムソケットは、"コネクションレス型ソケット"と呼ばれることもある。(ただし、本当に必要ならconnect()することができる。後述のconnect()を参照)。

ストリームソケットは、信頼性の高い双方向接続の通信ストリームです。ソケットに2つのアイテムを"1, 2"という順序で出力すると、反対側にも"1, 2"という順序で届きます。また、エラーも発生しません。もし、そうでないと主張する人がいたら、耳に指を突っ込んでララララと唱えてやりたいくらいだ。

ストリームソケットは何を使うのか？さて、皆さんはtelnetというアプリケーションをご存じでしょうか？これは、ストリームソケットを使用しています。入力した文字がすべて、入力した順番に届く必要がありますよね？また、WebブラウザはHTTP(Hypertext Transfer Protocol)を使っていますが、これもストリームソケットを使ってページを取得しています。実際、80番ポートのWebサイトにtelnetでアクセスし、"GET / HTTP/1.0"と入力してリターンを2回押すと、HTMLがダンプされて戻ってきますよ。

> telnetがインストールされておらず、インストールしたくない場合、またはtelnetがクライアントへの接続についてうるさい場合、ガイドにはtelnot7と呼ばれるtelnetのようなプログラムが付属しています。これは、このガイドのすべての必要性に対してうまく機能するはずです。(telnet は実際には仕様化されたネットワークプロトコルであり8、 telnot はこのプロトコルを全く実装していないことに注意してください)。

ストリームソケットは、どのようにしてこの高いレベルのデータ伝送品質を実現しているのでしょうか。それは、"TCP "として知られる "The Transmission Control Protocol"というプロトコルを使っているからです（TCPに関する非常に詳しい情報はRFC 793を参照してください）。TCPは、データが順次、エラーなく到着することを確認します。TCP"は"TCP/IP"の半分で、"IP"は"Internet Protocol"（RFC 791 参照）の略です。IP は主にインターネットのルーティングを扱い、一般にデータの完全性には責任を持ちません。

かっこいい。データグラムソケットについてはどうですか？なぜコネクションレス型と呼ばれるのでしょうか？どうなっているんだ？なぜ信頼性が低いのでしょうか？データグラムを送ると、それが届くかもしれません。データグラムを送信すると、それは到着するかもしれません。もし到着すれば、パケット内のデータはエラーフリーです。

データグラムソケットもルーティングにIPを使いますが、TCPではなく、"User Datagram Protocol"または"UDP"（RFC 768参照）を使用します。

なぜコネクションレス型なのか？まあ、基本的には、ストリームソケットのようにオープンな接続を維持する必要がないからです。パケットを作り、その上に宛先情報を含むIPヘッダを貼り付け、送信するだけでいいのです。接続は必要ない。一般的には、TCPスタックが使用できない場合や、パケットをいくつか落としても宇宙の終わりを意味しない場合に使用されます。アプリケーション例：tftp (trivial file transfer protocol, a little brother to FTP), dhcpcd (a DHCP client), マルチプレイヤーゲーム、ストリーミングオーディオ、ビデオ会議、などなど。

"ちょっと待った！tftpとdhcpcdはバイナリアプリケーションをあるホストから別のホストに転送するために使われているんだ！"。アプリケーションが到着したときに動作することを期待するならば、データが失われることはありえない! どんな黒魔術なんだ？"

さて、人間の友人ですが、tftpやそれに類するプログラムは、UDPの上に独自のプロトコルを載せています。例えば、tftpのプロトコルは、パケットを送信するごとに、受信者は"受け取ったよ！"というパケットを送り返さなければならない、と言っています。というパケット("ACK"パケット)を送り返さなければなりません。元のパケットの送信者は、例えば5秒間返信がない場合、最終的にACKを得るまでパケットを再送信することになります。この確認手続きは、信頼性の高いSOCK_DGRAMアプリケーションを実装する際に非常に重要です。

ゲーム、オーディオ、ビデオなどの信頼性の低いアプリケーションでは、ドロップされたパケットを無視するか、あるいは巧みに補正しようとします。(Quakeのプレイヤーは、この効果の発現を"呪われたラグ"という専門用語で知っていることでしょう。この場合の "acursed"は、極めて不敬な発言を意味する)

なぜ信頼性の低い基礎プロトコルを使うのか？理由は2つ、速度とスピードです。何が無事に到着したかを追跡し、順序立てて確認したりするよりも、発射して忘れる方がずっと速いのです。チャットメッセージを送るなら、TCPは素晴らしいです。世界中のプレイヤーの位置情報を毎秒40件送るなら、1件や2件が落ちてもそれほど問題ではないので、UDPは良い選択だと思います。

### 2.2 低レベルのナンセンスとネットワーク理論
先ほどプロトコルの階層化について触れましたので、そろそろネットワークの実際の仕組みについて、SOCK_DGRAMパケットがどのように構築されるのか、いくつかの例を挙げて説明しましょう。実際、このセクションは読み飛ばしても大丈夫でしょう。しかし、良い背景となります。

```
# データのカプセル化
Ethernet > IP > UDP > TFTP > Data
```

子供たちよ、データカプセル化について学ぶ時間だ! これはとても重要なことです。あまりに重要なので、Chico Stateでネットワークの授業を受けると、このことを学ぶことになるかもしれません;-)。基本的にはこうです：パケットが生まれ、パケットは最初のプロトコル（例えばTFTPプロトコル）によってヘッダー（まれにフッターも）でラップ（"カプセル化"）され、次のプロトコル（例えばUDP）によって全体が再びカプセル化され、さらに次のプロトコル（IP）によって、そしてハードウェア（物理）層の最後のプロトコル（例えばイーサネット）によって再びカプセル化されます。

他のコンピュータがパケットを受信すると、ハードウェアがイーサネットヘッダを、カーネルがIPとUDPヘッダを、TFTPプログラムがTFTPヘッダを取り除き、ようやくデータを手に入れることができるのです。

これでやっと悪名高いレイヤードネットワークモデル（通称"ISO/OSI"）について語れるようになった。このネットワークモデルは、他のモデルに比べて多くの利点を持つネットワーク機能のシステムを記述しています。例えば、データが物理的にどのように転送されるか（シリアル、シンイーサネット、AUI、何でも）を気にせずに、全く同じソケットプログラムを書くことができます。実際のネットワークハードウェアやトポロジーは、ソケットプログラマにとって透過的です。

さっそくですが、本格的なモデルのレイヤーを紹介します。ネットワーククラスの試験のために覚えておいてください。

- Application
- Presentation
- Session
- Transport
- Network
- Data Link
- Physical

物理層は、ハードウェア（シリアル、イーサネットなど）です。アプリケーション層は物理層から想像できる限り離れたところにあり、ユーザーがネットワークと対話する場所です。

さて、このモデルは非常に一般的なもので、本当にやろうと思えば、自動車の修理ガイドとして使うこともできるだろう。よりUnixに近いレイヤーモデルは次のようなものでしょう。

- Application Layer (telnet, ftp, etc.)
- Host-to-Host Transport Layer (TCP, UDP)
- Internet Layer (IP and routing)
- Network Access Layer (Ethernet, wi-fi, or whatever)

この時点で、これらのレイヤーが元のデータのカプセル化に対応していることがお分かりいただけたと思います。

シンプルなパケットを作るのに、どれだけの労力が必要なのか、おわかりいただけたでしょうか？じぇじぇじぇ! しかも、パケットヘッダを自分で "cat"を使って入力しなければならないのです! 冗談です。ストリームソケットの場合は、データをsend()するだけでいいんです。データグラムソケットでは、パケットを好きな方法でカプセル化し、sendto()で送るだけでいいのです。カーネルはあなたのためにトランスポート層とインターネット層を構築し、ハードウェアはネットワークアクセス層を構築するのです。ああ、現代の技術だ。

というわけで、ネットワーク理論についての簡単な解説を終わります。そうそう、ルーティングについて言いたいことを全部言うのを忘れていた：何もない！（笑）。その通り、全く話すつもりはありません。ルータはパケットをIPヘッダに分解し、ルーティングテーブルを参照し、ブラブラブラブラ。もし本当に気になるなら、IP RFCをチェックしてみてください。もし、あなたがそれについて学ぶことがなければ、まあ、あなたは生きていくでしょう。

## 3 IPアドレス、構造体、データマウンティング
ここからは気分転換にコードの話をするところです。

その前に、もっとノンコードの話をしましょう! イエーイ! まず最初にIPアドレスとポートについて少しお話したいと思いますので、それを整理します。それからソケットAPIがどのようにIPアドレスや他のデータを保存し、操作するかについて話します。

### 3.1 IPアドレス、バージョン4と6
ベン・ケノービがまだオビワン・ケノービと呼ばれていた頃、インターネット・プロトコル・バージョン4（IPv4）と呼ばれる素晴らしいネットワーク・ルーティング・システムが存在した。IPv4は4バイト（4オクテット）で構成されるアドレスで、一般的には次のように「ドットと数字」で記述されていました。`192.0.2.111`.

皆さんも一度は目にしたことがあるのではないでしょうか。

実際、この記事を書いている時点では、インターネット上のほぼすべてのサイトがIPv4を使っています。

オビ・ワンをはじめ、誰もが幸せだった。しかし、ヴィント・サーフという名の否定的な人物が、IPv4アドレスが足りなくなると警告を発したのです。

(ヴィント・サーフ氏は、IPv4による「破滅と暗黒の黙示録」の到来を警告するとともに、「インターネットの父」としても有名です。だから、私は彼の判断に二の足を踏む立場にはないのだ)。

アドレスが足りなくなる？そんなことがあるのでしょうか？つまり、32ビットのIPv4アドレスには何十億ものIPアドレスが存在するのです。本当に何十億台ものコンピュータがあるのだろうか？

Yes.

また、コンピュータが数台しかなく、10億という数字があり得ないほど大きいと誰もが思っていた当初、いくつかの大きな組織は、自分たちが使うために何百万というIPアドレスを惜しげもなく割り当てていたのです。(ゼロックス、MIT、フォード、HP、IBM、GE、AT&T、そしてアップルという小さな会社などです)。

実際、いくつかの応急処置がなかったら、とっくに使い果たしていたでしょう。

しかし今は、すべての人間がIPアドレスを持ち、すべてのコンピュータ、電卓、電話、パーキングメーター、そして（なぜか）子犬も、という時代です。

そして、IPv6が誕生したのです。ヴィント・サーフはおそらく不死身なので（たとえ肉体がこの世を去ったとしても、おそらく彼はインターネット2の奥底で超知的なELIZAプログラムとしてすでに存在している）、次のバージョンのインターネットプロトコルで十分なアドレスが確保できなければ、誰も彼の"だから言っただろう"という言葉を再び聞きたくはないだろう。

これは何を示唆しているのでしょうか？

もっとたくさんのアドレスが必要だということです。2倍どころか10億倍でもなく 1000兆倍でもなく 7900万ビリオン・トリリオンの数のアドレスが必要なのです そうこなくちゃ！

ビージェイ、それは本当なの？大きな数字を信じない理由があるんだ。" 32ビットと128ビットの差は大したことないように聞こえるかもしれない、96ビット多いだけだろ？しかし、私たちはここで累乗の話をしていることを忘れてはならない。32ビットは約40億個（2^32個）、128ビットは約340兆個（2^128個）の数字に相当するのだ。これは、宇宙の星1つに対して、100万個のIPv4インターネットがあるようなものです。

IPv4のドットや数字も忘れて、16進数で、2バイトの塊をコロンで区切って、このように表現しています。

```
2001:0db8:c9d2:aee5:73e3:934a:a5ae:9551
```

それだけではありません! 多くの場合、IPアドレスにはたくさんのゼロが含まれていますが、それらを2つのコロンで区切って圧縮することができます。そして、各バイトペアの先頭のゼロを省くことができます。例えば、次のようなアドレスのペアは、それぞれ等価です。

```
2001:0db8:c9d2:0012:0000:0000:0000:0051
2001:db8:c9d2:12::51

2001:0db8:ab00:0000:0000:0000:0000:0000
2001:db8:ab00::

0000:0000:0000:0000:0000:0000:0000:0001
::1
```

アドレス ::1 はループバックアドレスです。常に"今走っているこのマシン"という意味です。IPv4では、ループバックアドレスは`127.0.0.1`です。

最後に、IPv6アドレスのIPv4互換モードですが、これは皆さんが遭遇する可能性のあるものです。例えば、IPv4アドレスの`192.0.2.33`をIPv6アドレスとして表現したい場合、以下のような表記になります。`::ffff:192.0.2.33` となります。

本気で楽しみたいんです。

実際、IPv6の開発者たちは、何兆個ものアドレスを軽率にも予約用に切り捨てたほど、IPv6は楽しいものなのですが、数が多すぎて、正直言って、もう誰が数えているのでしょうか？銀河系のすべての惑星のすべての男性、女性、子供、子犬、そしてパーキングメーターのために十分な数が残されています。信じてくれ、銀河系のどの星にもパーキングメーターはあるんだ。本当なんだ。

#### サブネット
組織的な理由から、"このIPアドレスのこのビットまでの部分がネットワーク部分、それ以外がホスト部分"と宣言するのが便利な場合があります。

例えば、IPv4の場合、`192.0.2.12`とありますが、最初の3バイトがネットワークで、最後の1バイトがホストと言うことができます。あるいは、別の言い方をすれば、ネットワーク`192.0.2.0`上のホスト12について話していることになります（ホストであるバイトをゼロにしているところをご覧ください）。

そして、さらに時代遅れの情報を! 準備はいいですか？古代では、サブネットには"クラス"があり、アドレスの最初の1バイト、2バイト、3バイトがネットワーク部分でした。運良く1バイトがネットワーク、3バイトがホストの場合、ネットワーク上に24ビット分のホスト（1600万程度）を持つことができます。これが"クラスA"のネットワークです。一方、"クラスC"は、ネットワークが3バイト、ホストが1バイトで、256台のホスト（ただし、予約された数台は除く）を持ちます。

ご覧のように、Aクラスがほんの少し、Cクラスが大量に、そして真ん中にBクラスが何個かある状態でした。

IPアドレスのネットワーク部分は、ネットマスクと呼ばれるもので記述され、IPアドレスとビット単位でANDすることでネットワーク番号を取得します。ネットマスクは通常、`255.255.255.0`のようなものです（例えば、このネットマスクでは、IPが`192.0.2.12`なら、ネットワークは`192.0.2.12` AND `255.255.255.0` で `192.0.2.0` となり ます）。

クラスCのネットワークはすぐに足りなくなったし、クラスAのネットワークも足りなくなったので、わざわざ尋ねる必要はありません。この問題を解決するために、権力者たちはネットマスクを 8、16、24 のどれでもなく、任意のビット数にすることを許可しました。例えば、 `255.255.255.252` というネットマスクは、30 ビットのネットワークと、2 ビットのホストで、ネットワーク上に 4 台のホストが存在することになります。(ネットマスクは常に1ビットの束と0ビットの束であることに注意してください)。

しかし、`255.192.0.0`ような大きな数字の羅列をネットマスクとして使うのは、ちょっと扱いにくいですね。まず、それが何ビットなのかが直感的にわからないし、コンパクトでもない。そこで、新スタイルが登場し、よりすっきりしました。IPアドレスの後にスラッシュを付けて、その後に10進数でネットワークのビット数を指定するだけです。こんな感じです。`192.0.2.12/30`.

あるいは、IPv6の場合、こんな感じ。`2001:db8::/32` または `2001:db8:5413:4028::9db9/64` のようなものです。

#### ポート番号
以前、インターネット層（IP）とホスト間トランスポート層（TCPとUDP）を分離したレイヤード・ネットワークモデルを紹介しましたが、覚えているでしょうか。次の段落の前に、そのことをしっかり覚えておいてください。

IPアドレス（IP層で使われる）の他に、TCP（ストリームソケット）や、偶然にもUDP（データグラムソケット）で使われるアドレスがあることが判明したのです。それは、ポート番号です。これは16ビットの数字で、接続のためのローカルアドレスのようなものです。

IPアドレスはホテルの番地、ポート番号は部屋番号だと思ってください。自動車に例えると、こんな感じでしょうか。

例えば、メールの受信とWebサービスの両方を扱うコンピュータを用意したい場合、1つのIPアドレスを持つコンピュータでこの2つを区別する方法はあるのでしょうか？

さて、インターネット上のサービスには、それぞれ異なるウェルノウン・ポート番号が設定されています。IANAのポート一覧か、Unixなら/etc/servicesファイルで確認できます。HTTP（ウェブ）はポート80、telnetはポート23、SMTPはポート25、ゲームDOOMはポート666を使用、などなど。1024以下のポートは特殊とみなされることが多く、通常、使用するにはOSの特別な権限が必要です。

といったところでしょうか。
