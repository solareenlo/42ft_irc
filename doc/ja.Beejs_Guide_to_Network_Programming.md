# Beej's Guide to Network Programming
Using Internet Sockets

Brian “Beej Jorgensen” Hall

v3.1.5, Copyright © November 20, 2020

## 2 ソケットとは
ソケットという言葉をよく耳にしますが、そもそも"ソケット"とは何なのでしょうか？それは、標準的なUnixのファイルディスクリプタを使って他のプログラムと会話するための方法です。

何と？

Unixのハッカーが、"なんてこった、Unixのすべてはファイルだ！"と言ったのを聞いたことがあるかもしれません。その人が言っているのは、Unixのプログラムが何らかのI/Oを行うとき、ファイル記述子に対して読み書きを行うという事実のことでしょう。ファイルディスクリプタは、単純に、開いているファイルに関連する整数です。しかし、このファイルは、ネットワーク接続、FIFO、パイプ、ターミナル、ディスク上のファイルなど、あらゆるものになり得ます（ここが重要）。Unix ではすべてがファイルなのです! だから、インターネット上で他のプログラムと通信したいときは、ファイル記述子を介して行うことになる。

"ネットワーク通信のためのファイルディスクリプタはどこで手に入るのでしょうか、お利口さんですね "というのが、今あなたが考えている最後の質問でしょうが、とにかくそれに答えてあげましょう。システムルーチンのsocket()を呼び出すのです。socket()システムルーチンを呼び出すと、ソケットディスクリプタが返され、それを使って特殊な send() と recv() (man send, man recv) ソケットコールを使って通信を行います。

"でもね！"あなたは今まさにそう叫んでいるかもしれません。"ファイルディスクリプタなら、なぜネプチューンの名において、通常の read() や write() 呼び出しでソケットを通して通信できないんだ？" と。短い答えは、"できる！"です。もっと長い答えは、"できるけど、send() や recv() の方がデータ転送をより細かく制御できる "です。

次は何？どうでしょう、ソケットにはいろいろな種類がありますね。DARPA インターネットアドレス (インターネットソケット)、ローカルノード上のパス名 (Unix ソケット)、CCITT X.25 アドレス (X.25 ソケット、無視しても大丈夫)、そしておそらくあなたが実行する Unix のフレーバーに応じて他の多くの種類があります。この文書では、最初のインターネットソケットのみを扱います。

### 2.1 2種類のインターネットソケット
これは何？インターネットソケットには2種類ある？そうです。まあ、違うけど。嘘です。もっとあるんだけど、怖がらせたくなかったんだ。ここでは2種類しか話しません。ただし、この文章では、"Raw Sockets"も非常に強力なので、ぜひ調べてみてください、と書いています。

わかったよ、もう。この2つのタイプは何ですか？一つは"ストリームソケット"、もう一つは"データグラムソケット"で、以下それぞれ"SOCK_STREAM""SOCK_DGRAM"と表記することがあります。データグラムソケットは、"コネクションレス型ソケット"と呼ばれることもある。(ただし、本当に必要ならconnect()することができる。後述のconnect()を参照)。

ストリームソケットは、信頼性の高い双方向接続の通信ストリームです。ソケットに2つのアイテムを"1, 2"という順序で出力すると、反対側にも"1, 2"という順序で届きます。また、エラーも発生しません。もし、そうでないと主張する人がいたら、耳に指を突っ込んでララララと唱えてやりたいくらいだ。

ストリームソケットは何を使うのか？さて、皆さんはtelnetというアプリケーションをご存じでしょうか？これは、ストリームソケットを使用しています。入力した文字がすべて、入力した順番に届く必要がありますよね？また、WebブラウザはHTTP(Hypertext Transfer Protocol)を使っていますが、これもストリームソケットを使ってページを取得しています。実際、80番ポートのWebサイトにtelnetでアクセスし、"GET / HTTP/1.0"と入力してリターンを2回押すと、HTMLがダンプされて戻ってきますよ。

> telnetがインストールされておらず、インストールしたくない場合、またはtelnetがクライアントへの接続についてうるさい場合、ガイドにはtelnot7と呼ばれるtelnetのようなプログラムが付属しています。これは、このガイドのすべての必要性に対してうまく機能するはずです。(telnet は実際には仕様化されたネットワークプロトコルであり8、 telnot はこのプロトコルを全く実装していないことに注意してください)。

ストリームソケットは、どのようにしてこの高いレベルのデータ伝送品質を実現しているのでしょうか。それは、"TCP "として知られる "The Transmission Control Protocol "というプロトコルを使っているからです（TCPに関する非常に詳しい情報はRFC 793を参照してください）。TCPは、データが順次、エラーなく到着することを確認します。TCP"は"TCP/IP"の半分で、"IP"は"Internet Protocol"（RFC 791 参照）の略です。IP は主にインターネットのルーティングを扱い、一般にデータの完全性には責任を持ちません。

かっこいい。データグラムソケットについてはどうですか？なぜコネクションレス型と呼ばれるのでしょうか？どうなっているんだ？なぜ信頼性が低いのでしょうか？データグラムを送ると、それが届くかもしれません。データグラムを送信すると、それは到着するかもしれません。もし到着すれば、パケット内のデータはエラーフリーです。

データグラムソケットもルーティングにIPを使いますが、TCPではなく、"User Datagram Protocol"または"UDP"（RFC 768参照）を使用します。

なぜコネクションレス型なのか？まあ、基本的には、ストリームソケットのようにオープンな接続を維持する必要がないからです。パケットを作り、その上に宛先情報を含むIPヘッダを貼り付け、送信するだけでいいのです。接続は必要ない。一般的には、TCPスタックが使用できない場合や、パケットをいくつか落としても宇宙の終わりを意味しない場合に使用されます。アプリケーション例：tftp (trivial file transfer protocol, a little brother to FTP), dhcpcd (a DHCP client), マルチプレイヤーゲーム、ストリーミングオーディオ、ビデオ会議、などなど。

"ちょっと待った！tftpとdhcpcdはバイナリアプリケーションをあるホストから別のホストに転送するために使われているんだ！"。アプリケーションが到着したときに動作することを期待するならば、データが失われることはありえない! どんな黒魔術なんだ？"

さて、人間の友人ですが、tftpやそれに類するプログラムは、UDPの上に独自のプロトコルを載せています。例えば、tftpのプロトコルは、パケットを送信するごとに、受信者は"受け取ったよ！"というパケットを送り返さなければならない、と言っています。というパケット("ACK"パケット)を送り返さなければなりません。元のパケットの送信者は、例えば5秒間返信がない場合、最終的にACKを得るまでパケットを再送信することになります。この確認手続きは、信頼性の高いSOCK_DGRAMアプリケーションを実装する際に非常に重要です。

ゲーム、オーディオ、ビデオなどの信頼性の低いアプリケーションでは、ドロップされたパケットを無視するか、あるいは巧みに補正しようとします。(Quakeのプレイヤーは、この効果の発現を"呪われたラグ"という専門用語で知っていることでしょう。この場合の "acursed "は、極めて不敬な発言を意味する)

なぜ信頼性の低い基礎プロトコルを使うのか？理由は2つ、速度とスピードです。何が無事に到着したかを追跡し、順序立てて確認したりするよりも、発射して忘れる方がずっと速いのです。チャットメッセージを送るなら、TCPは素晴らしいです。世界中のプレイヤーの位置情報を毎秒40件送るなら、1件や2件が落ちてもそれほど問題ではないので、UDPは良い選択だと思います。

### 2.2 低レベルのナンセンスとネットワーク理論
先ほどプロトコルの階層化について触れましたので、そろそろネットワークの実際の仕組みについて、SOCK_DGRAMパケットがどのように構築されるのか、いくつかの例を挙げて説明しましょう。実際、このセクションは読み飛ばしても大丈夫でしょう。しかし、良い背景となります。

```
# データのカプセル化
Ethernet > IP > UDP > TFTP > Data
```

子供たちよ、データカプセル化について学ぶ時間だ! これはとても重要なことです。あまりに重要なので、Chico Stateでネットワークの授業を受けると、このことを学ぶことになるかもしれません;-)。基本的にはこうです：パケットが生まれ、パケットは最初のプロトコル（例えばTFTPプロトコル）によってヘッダー（まれにフッターも）でラップ（"カプセル化"）され、次のプロトコル（例えばUDP）によって全体が再びカプセル化され、さらに次のプロトコル（IP）によって、そしてハードウェア（物理）層の最後のプロトコル（例えばイーサネット）によって再びカプセル化されます。

他のコンピュータがパケットを受信すると、ハードウェアがイーサネットヘッダを、カーネルがIPとUDPヘッダを、TFTPプログラムがTFTPヘッダを取り除き、ようやくデータを手に入れることができるのです。

これでやっと悪名高いレイヤードネットワークモデル（通称"ISO/OSI"）について語れるようになった。このネットワークモデルは、他のモデルに比べて多くの利点を持つネットワーク機能のシステムを記述しています。例えば、データが物理的にどのように転送されるか（シリアル、シンイーサネット、AUI、何でも）を気にせずに、全く同じソケットプログラムを書くことができます。実際のネットワークハードウェアやトポロジーは、ソケットプログラマにとって透過的です。

さっそくですが、本格的なモデルのレイヤーを紹介します。ネットワーククラスの試験のために覚えておいてください。

- Application
- Presentation
- Session
- Transport
- Network
- Data Link
- Physical

物理層は、ハードウェア（シリアル、イーサネットなど）です。アプリケーション層は物理層から想像できる限り離れたところにあり、ユーザーがネットワークと対話する場所です。

さて、このモデルは非常に一般的なもので、本当にやろうと思えば、自動車の修理ガイドとして使うこともできるだろう。よりUnixに近いレイヤーモデルは次のようなものでしょう。

- Application Layer (telnet, ftp, etc.)
- Host-to-Host Transport Layer (TCP, UDP)
- Internet Layer (IP and routing)
- Network Access Layer (Ethernet, wi-fi, or whatever)

この時点で、これらのレイヤーが元のデータのカプセル化に対応していることがお分かりいただけたと思います。

シンプルなパケットを作るのに、どれだけの労力が必要なのか、おわかりいただけたでしょうか？じぇじぇじぇ! しかも、パケットヘッダを自分で "cat "を使って入力しなければならないのです! 冗談です。ストリームソケットの場合は、データをsend()するだけでいいんです。データグラムソケットでは、パケットを好きな方法でカプセル化し、sendto()で送るだけでいいのです。カーネルはあなたのためにトランスポート層とインターネット層を構築し、ハードウェアはネットワークアクセス層を構築するのです。ああ、現代の技術だ。

というわけで、ネットワーク理論についての簡単な解説を終わります。そうそう、ルーティングについて言いたいことを全部言うのを忘れていた：何もない！（笑）。その通り、全く話すつもりはありません。ルータはパケットをIPヘッダに分解し、ルーティングテーブルを参照し、ブラブラブラブラ。もし本当に気になるなら、IP RFCをチェックしてみてください。もし、あなたがそれについて学ぶことがなければ、まあ、あなたは生きていくでしょう。
